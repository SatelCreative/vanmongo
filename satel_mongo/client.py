from datetime import datetime
from typing import Any, ClassVar, Dict, Generic, Optional, Type, TypeVar

from motor.motor_asyncio import AsyncIOMotorClient
from pydantic import BaseModel, Field
from shortuuid import ShortUUID


class BaseDocument(BaseModel):
    """BaseDocument"""

    """MongoDB Collection"""
    collection: ClassVar[str] = NotImplemented
    """Autogenerated _id"""
    object_id: Any = Field(alias="_id")
    """Short unique id"""
    id: str
    """Date last modified"""
    updated_at: datetime
    """Date created"""
    created_at: datetime

    def __init_subclass__(cls, *args, collection: Optional[str] = None, **kwargs):

        # NOTE: known issue in mypy
        # https://github.com/python/mypy/issues/4660
        super().__init_subclass__(*args, **kwargs)  # type: ignore

        if collection:
            cls.collection = collection
        else:
            cls.collection = f"{cls.__name__.lower()}s"


TContext = TypeVar("TContext", bound=BaseModel)
TDocument = TypeVar("TDocument", bound=BaseDocument)


class Config(BaseModel):
    mongo_url: str
    mongo_database: str
    meilsearch_url: Optional[str] = None
    meilsearch_key: Optional[str] = None


class Client(Generic[TContext]):
    """Client"""

    __client: ClassVar[Any] = NotImplemented
    config: ClassVar[Config] = NotImplemented
    context: Optional[TContext] = None

    def __init__(self, context: TContext = None):
        if self.__client == NotImplemented:
            raise Exception("Client cannot be used before it has been initialized")

        self.context = context

    @classmethod
    async def initialize(cls, mongo_url: str = None, mongo_database: str = None):
        cls.config = Config(
            mongo_url=mongo_url,
            mongo_database=mongo_database,
        )
        cls.__client = AsyncIOMotorClient(cls.config.mongo_url)

    @property
    def db(self):
        return self.__client[self.config.mongo_database]

    def use(
        self: "Client", Document: Type[TDocument]
    ) -> "Collection[TDocument, TContext]":
        return Collection[TDocument, TContext](client=self, Document=Document)


class Collection(Generic[TDocument, TContext]):
    """Collection"""

    client: Client[TContext]
    Document: Type[TDocument]

    def __init__(self, client: Client[TContext], Document: Type[TDocument]):
        if Document.collection == NotImplemented:
            raise Exception("invalid Document")

        self.client = client
        self.Document = Document

    @property
    def collection(self):
        return self.client.db[self.Document.collection]

    async def find_one_by_id(self, id: str) -> Optional[TDocument]:
        raw = await self.collection.find_one({"id": id})
        return self.Document.parse_obj(raw) if raw else None

    async def create_one(self, document: Dict[str, Any]) -> TDocument:
        """Create a new document"""

        now = datetime.utcnow()
        # Keep same precision as mongo
        now = now.replace(microsecond=int(round(now.microsecond, -3)))

        document.update(
            {
                "_id": "",  # Removed before insert
                "id": ShortUUID().random(length=10),
                "created_at": now,
                "updated_at": now,
            }
        )

        doc = self.Document.parse_obj(document)

        doc_dict = doc.dict(by_alias=True)
        doc_dict.pop("_id", None)  # Remove _id

        inserted_result = await self.collection.insert_one(doc_dict)
        doc.object_id = inserted_result.inserted_id  # Add generated _id

        return doc
